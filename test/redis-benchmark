#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable +A 16 +K true
-mode(compile).
-compile(inline).
-import(redis_proto, [line/1, line/2, line/3, line/4, line_list/1,
         bulk/3, bulk/4, mbulk/1]).

-define(HOST, localhost).
-define(PORT, 6379).

-record(config, {
    host = ?HOST, 
    port = ?PORT,
    clients = 5,
    requests = 10000
    }).

usage() ->
    io:format("usage:\n"),
    io:format(" redis-benchmark [options]\n"),
    io:format("  -h Host     - the redis server (default localhost)\n"),
    io:format("  -p Port     - the redis server port (default 6379) \n"),
    io:format("  -c Clients  - the concurrent request client number (default 5) \n"),
    io:format("  -n Count    - the total requests count (default 10000) \n"),
    io:format("\n\n").

main(Args) ->
    usage(),
    Config = parse_args(Args),
    %io:format("args is ~p", [Args]),
    crypto:start(),
    code:add_path("../ebin"),
    true = erlang:system_info(smp_support),
    redis_app:start(),
    ok = redis_app:single_server(Config#config.host, Config#config.port, 2, "litao"),
    %ok = redis:multi_servers([{Config#config.host, 6379, 1}, {Config#config.host, 6380, 1}], "litao"),

    Redis = redis_app:client(single),
    [do_bench(F, Config#config.requests, Config#config.clients, Title) ||
        {F, Title} <- action_list(Redis)].

do_bench(F, N, Conc, Title) ->
    NP = N div Conc,
    Parent = self(),

    T1 = now(),
    % spawn the clients
    Pids = [start_client(Parent, F, NP) || _ <- lists:duplicate(Conc, 0)],
    Counts = 
    [receive 
        {ack, P, CN} ->
            CN
    end || P <- Pids],
    T2 = now(),

    T = timer:now_diff(T2, T1),
    N2 = lists:sum(Counts),
    Second = T/1000000,
    io:format("===== ~p ======\n", [Title]),
    io:format("~p requests completed in ~.2f s\n", [N2, Second]),
    io:format("~p requests per second\n", [round(N2/Second)]),
    ok.

start_client(Parent, F, NP) ->
    spawn(
    fun() ->
        do_times(F, NP),
        Parent ! {ack, self(), NP}
    end).

do_times(_F, 0) ->
    ok;
do_times(F, N) ->
    case is_function(F, 0) of
        true ->
            F();
        false ->
            F(integer_to_list(N))
    end,
    do_times(F, N-1).

-define(F(Expr),
    (fun() -> Expr end)).

action_list(Redis) ->
    [{?F(Redis:ping()), "PING"},
     {fun(N) -> Redis:set("foo_rand000000000000", N) end, "SET"},
     {?F(Redis:get("foo_rand000000000000")), "GET"},
     {?F(Redis:incr("counter_rand000000000000")), "INCR"},
     {?F(Redis:list_push_head("mylist", <<"bar">>)), "LPUSH"},
     {?F(Redis:list_pop_head("mylist")), "LPOP"}
    ].

parse_args(Args) ->
    parse_args(Args, #config{}).

parse_args(["-h", Host | T], Config) ->
    parse_args(T, Config#config{host = Host});
parse_args(["-p", Port | T], Config) ->
    parse_args(T, Config#config{port = list_to_integer(Port)});
parse_args(["-c", Clients | T], Config) ->
    parse_args(T, Config#config{clients = list_to_integer(Clients)});
parse_args(["-n", N | T], Config) ->
    parse_args(T, Config#config{requests = list_to_integer(N)});
parse_args([_ | T], Config) ->
    parse_args(T, Config);
parse_args([], Config) ->
    Config.
